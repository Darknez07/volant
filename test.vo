struct Kaka {
    a, b: i32 = 0, 1
    c, d: i32 = 2, 3
}

struct Kaka2 {
    ..Kaka
    e, f: i32 = 4, 5
}

enum Kakak {
    a = 0,
    b,
    c,
    d
}

tuple Kakakak {i8, i32}

// heh: *func();
/*
function: func() i32 = func () i32 {
    return 100
}

input: func() i32 = func(str: __mem_block) __mem_block {
    scanf("%s", str._ptr);
    return str;
} 

main: func() i32 = func() i32 {
    x: [10]i8 = [0, 1, 2];
    y: [10]*i8;
    z: [10]*const u8;
    
    pri32f("function() returned %i\n", function());
    
    str, num: *i8, i32 = "hehehehe", 3 - 2 / 2 * -5 + 10 
    
    defer pri32f("Haha I'll be pri32ed on the last\n")

    a: *dynamic i8 = &(new i8)
    // a: i8 = "hehe"

    m: dynamic []i32

    m = new [100]i32
    pri32f("Size of m is %zu. Length of m is %zu.\n", size(m), len(m))
    delete m
    pri32f("Deleted m. Size of m is %zu. Length of m is %zu.\n", size(m), len(m));

    m = new [200]i32
    pri32f("Size of m is %zu. Length of m is %zu.\n", size(m), len(m))
    
    uninitialized: i32;
    
    cast(m._ptr, i32ptr)[0] = 0

    pri32f("size is %li.\n", size);
    pri32f("m is %i.\nLength of m is %zu\n", m[0], size(m))
    pri32f("function() returned %i.\n", function())

    p: Kaka = (Kaka){a: 0, b: 0}
    q: Kakakak = (Kakakak){0, 0}

    pri32f("p.a is %i and p.b is %i.\n", p.a, p.b);
    printf("q[0] is %i and q[1] is %i.\n\n", q._0, q._1)
    
    mem: *i8 = malloc(sizeof(i8[10]))
    // mem: i8[10];

    printf("Enter something: ")
    scanf("%s", mem)

    printf("First letter of what you entered is %c.\n", mem[0])
    printf("Second letter of what you entered is %c.\n", (mem+1)[0])
    printf("You entered %s.\n\nRandom stuff below...\n", mem)

    free(mem)

    if x: i32 = 0; num {
        printf("str is \"%s\" and num is %i.\n", str, num)
        x ? printf("hehe x is not xero.\n\n") : printf("hehe x is zero.\n\n")
    }
    
    for i: i32 = 10; i; i-- {
        printf("i is %i and num is %i\n", i, num)
    }

    switch p: i32 = 0; num {
    case 90:
        printf("num is 90. p is %i.\n", cast(p, i32))
        break
    default:
        printf("num is not 90. p is %i.\n", p)
    }

    
    printf("\nhaha eternal heap allocater goes brr..\n")
    
    for i: long = 0;; ++i {
        new i8
        if i % 10000 == 0 {
            printf("\rallocated %li bytes", i)
        }
    }
    
    return 0
}

*/
o: [10]***func(i32) **i32;

typedef haha [100]u16;
typedef haa u8

function := func () dynamic dynamic dynamic []i32 {
    nums := new dynamic dynamic []i32;

    nums[0] = new dynamic []i32
    nums[0][0] = new [10]i32
    nums[0][0][0] = '\U10101010'
    
    return nums;
};

main := func() i32 {
    printf("haha I wont decay to pointer.\n");
    nums := function();
    numsptr := &nums;

    printf("Length of nums is %zu. Size of nums is %zu.\n", len(nums), size(nums));
    delete nums[0][0], nums[0], nums
    
    printf("haha I'll decay to pointer. %i.\n", function()[0][0][0]);

    printf("Kakak.a is %i.\n", cast(i32)Kakak.a);
    
    str := "hehehe"
    printf("hehe is %s.\n", str)

    dynStrs: [1]dynamic []u8 = [new [7]u8]

    memcpy(&dynStrs[0][0], str, 7);
    printf("dynamic string is %s.\n", &dynStrs[0][0]);

    x: [100]i32;

    printf("Length of x is %zu. Size of x is %zu.\n", len(x), size(x));
    printf("Length of a is %zu. Size of a is %zu.\n", len(o), size(o));

    tupl := (Kakakak){0, 1};
    printf("tupl[0] is %i. tupl[1] is %i\n", tupl[0], tupl[1])
    
    strct := (Kaka2){a: 1}
    strct2 := cast(Kaka)strct
    return 0
};
